# 知识点

2. make和new的区别
> 1.make适用slice、map、chan；new适用基本类型；
> 2.make返回引用，new返回地址
> 3.make初始空间，new为零值，并回收内存空间
3. defer和return执行顺序
> defer在return执行后面
> defer压栈原理，后进先出
> defer拷贝传值，不会影响return值； 如果地址传参，则会影响return值
4. print
> 1. %v(只打印结构体val)
> 2. %+v(打印结构体key/val)
> 3. %#v(打印结构体命名空间、key/val)
```go
func TestStruct(t *testing.T) {
	type Ts struct {
		Name string `json:"name"`
		Age  int    `json:"age"`
	}

	obj := Ts{
		Name: "哈哈怪",
		Age:  18,
	}
	fmt.Printf("%v\n", obj)
	fmt.Printf("%+v\n", obj)
	fmt.Printf("%#v\n", obj)
}

```
Output:
```
{哈哈怪 18}
{Name:哈哈怪 Age:18}
main.Ts{Name:"哈哈怪", Age:18}
PASS
```
5. 空结构体的作用
> 1. 不占任何空间
> 2. 拓展普通结构体时的内存对齐， 小的在前面排列
> [参考链接](https://juejin.cn/post/7244809769794207801)

# 基本类型
## 切片
1. slice如果可以知道大小， 那么最好在创建时指定大小，来节省空间以及多余的扩容操作
```go
make([]int, 0, len(xxx))
```
## map
1. map元素遍历时顺序是随机的， 所以请不要依赖map的顺序
2. 
## 函数方法
1. 最好定义方法  而不是函数(类似成员方法，而不是函数)
```go
// 方法
func (structName) func1() {

}

// 函数
func func2() {

}
```
如果定义成方法，那么同一个包下可能会有名称冲突的问题

## for循环
1. for循环里 传递value引用 将会全是最后一个元素内容
```go
// 这里不能为了考虑节省空间而使用指针
for _, value := range sliceList {
    go Get(&value) // value全是sliceList的最后一个元素内容
}
应该是
for _, value := range sliceList {
    Get(value) 
}

或

for _, value := range sliceList {
    value := value
    go Get(&value) 
}
```

# 并发
## 协程中的panic
panic触发只会中断当前协程的执行，不会影响其他协程，所以如果在为了能捕获到协程中的panic错误，我们应该用recover()进行捕捉处理, 发现问题，解决问题
例如:
```go
func doSomeThing() error {
	fmt.Println("do some thing...")
	panic("test")
	return nil
}

func main() {
	for i := 10; i > 0; i-- {
		go func() {
			if err := doSomeThing(); err != nil {
				fmt.Println(err.Error())
			}
		}()
	}
	time.Sleep(1)
}
```
这里创建的子协程中的panic不会被发现, 我们需要用recover进行捕获
```go
package main

import (
	"fmt"
	"time"

	"github.com/spf13/cast"
)

func doSomeThing() error {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(cast.ToString(err))
		}
	}()
	fmt.Println("do some thing...")
	panic("test")

	return nil
}

func main() {
	for i := 10; i > 0; i-- {
		go func() {
			if err := doSomeThing(); err != nil {
				fmt.Println("doSomeThing err:", err.Error())
			}
		}()
	}
	time.Sleep(1)
}
```

# 并发编程
## 协程panic
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	for i := 10; i > 0; i-- {
		wg.Add(1)
		go func() {
			defer func() {
				fmt.Println("done")
				wg.Done()
				if err := recover(); err != nil {
					fmt.Println("panic recover")
				}

			}()
			// defer wg.Done()
			func() {
				panic("test panic")
			}()
		}()
	}
	wg.Wait()
	fmt.Println(2)
}
```

## 优雅重启(TODO)