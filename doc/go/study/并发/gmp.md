> 1. 演变历史
>
>    - 串行
>    - 多进程/多线程
>    - 协程
>      - 用户态 持有协程
>      - 内核态分配线程
>
> 2. 协程(用户态)和线程(内核态)的对应关系
>
>    - 1:1
>
>    - n:1
>
>    - n:m
>
> 3.  goroutine + channel 实现并发
>
> 4. 调度器
>
>    - 废弃的调度器GM模型
>    - 当前的GMP模型
>      - G - 用户态线程， 不存储系统分配资源相关东西，仅有几KB 较线程小， 切换代价小
>        - G的几个状态
>          - waiting
>          - runnable
>          - running
>      - M -  thread 和系统资源CPU绑定的核心态线程， maxprocess概念   表示最大并发数
>      - P -   process  G和M之间的中间层， 可以通过P将其维护的本地队列中的G分配给M进行执行
>      - 全局队列 - 在多个P的本地队列上，又有全局队列， 如果P中的本地队列空可以从全局队列中拉取G 进行处理， 同样的如果P维护的本地队列满了之后， 会将本地队列中一半的G追加到全局队列
>      - P对应的本地队列， 每个P维护一个本地队列，
>      - M线程执行任务得需要获取P处理器,  先从P的本地队列，  空则全局队列拿 或者其他P的本地队列偷取
>    - 策略
>      - work  stealing  线程无G可执行时  偷取其他队列任务  而不是销毁线程  达到复用目的
>      - hand off 当前G系统调用阻塞时， 线程释放P，让P找空闲线程绑定执行
>      - 最多有GOMAXPROCS个线程 同时在多个CPU上执行，达到并行
>      - 抢占式：分配时长由操作系统控制， goroutinue每个协程最多占用CPU10ms，防止其他Goroutine饿死







# 参考

- https://learnku.com/articles/41728#replies