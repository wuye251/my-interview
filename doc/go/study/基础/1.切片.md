> 总结下go语言中关于**切片**的相关概念和使用上的小细节
### [数组和切片的异同](https://golang.design/go-questions/slice/vs-array/)
和切片对应的数据类型是数组， 他两的区别有如下：

1. 数组空间大小是**定长**，切片**动态可扩展**大小

2. 数组就是分配一片连续的内存空间,  slice是一个结构体, 包含：长度，容量，底层数组指针

[源码中定义如下](https://github.com/golang/go/blob/master/src/runtime/slice.go#L15):

```golang
// src/runtime/slice.go
type slice struct {
	array unsafe.Pointer //指向存储实际数据的数组类型的指针
	len   int //实际元素个数
    cap   int //容量(可以容纳的最大元素个数)
}
```

###  [切片扩容](https://golang.design/go-questions/slice/grow/)

- 切片append时，当`len > cap`时，就会触发扩容，go底层通过策略尽可能少的减少扩容产生的内存开辟回收操作，提高效率
- 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4
[扩容部分源码](https://github.com/golang/go/blob/master/src/runtime/slice.go#L200)
```go
//go1.18 src/runtime/slice.go +193
  ...
  ...
	newcap := old.cap
	doublecap := newcap + newcap //两倍扩容
	if cap > doublecap {
		newcap = cap
	} else {
		const threshold = 256 //默认阈值
		if old.cap < threshold { //没到阈值 则两倍扩容
			newcap = doublecap
		} else {
			// Check 0 < newcap to detect overflow
			// and prevent an infinite loop.
			for 0 < newcap && newcap < cap {  
				// Transition from growing 2x for small slices
				// to growing 1.25x for large slices. This formula 
				// gives a smooth-ish transition between the two.
				newcap += (newcap + 3*threshold) / 4  //如果到了阈值 则是当前容量+3*阈值256 / 4 
			}
			// Set newcap to the requested cap when
			// the newcap calculation overflowed.
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
```

> - [ ] slice的扩容策略 ？ 
> - [ ] 内存对齐是什么？

### 切片作为参数传递

> 官方打假：Go函数传参只有值传递
>
> 看完*传值、传指针、传引用*的概念后，如果你坚持认为是传引用，好，大叔要在这里直接把你击垮。
>
> 根据Go官方文档声明：*Go里面函数传参只有值传递一种方式*。也就是说，在Go中，函数的传参只有传值一种方式。[官方文档传送门](https://link.juejin.cn/?target=https%3A%2F%2Fgolang.org%2Fref%2Fspec%23Calls)
>
> ------- 引自https://juejin.cn/post/6888117219213967368

在知道go函数传参只有值传递后，我们区分几个传参类型

1. 值传递  -- 仅将其值传递过来，函数会临时拷贝副本，函数中修改的都是拷贝的副本，不影响实参
2. 引用传递 -- 将指向实参的地址传递过去， 函数也会拷贝副本， 但是其指向地址是实参， 所以在函数中修改副本指向的地址内容，也意味着修改了实参

#### 值传递

在切片值传递时， 会拷贝副本

即 拷贝了下面的这个结构体实例， 但是注意， **实际的元素内容，是存储在slice.array中 而其又是存的指针， 故相当于`元素值`是通过地址引用传递过去的**

```go
type slice struct {
	array unsafe.Pointer 
	len   int 
    cap   int 
}
```

下面举个例子：

```golang
func main() {
	s := []int{1, 2, 3}
	fmt.Printf("init ptr %p val %v\n", &s, s)

	changeSlice(s)
	fmt.Printf("ret  ptr %p val %v\n", &s, s)

}

func changeSlice(s []int) {
	fmt.Printf("------ changeSlice ptr %p val %v\n", &s, s)
	for k := range s {
		s[k] += 1
	}
	fmt.Printf("------ changeSlice ptr %p val %v\n", &s, s)
}
```

在`changeSlice`中 修改元素值，还是会影响实参`s`的值， 因为实参、形参两个指向的`slice.array`地址是相同的

结果：

```golang
init ptr 0xc000004078 val [1 2 3]
------ changeSlice ptr 0xc0000040a8 val [1 2 3]
------ changeSlice ptr 0xc0000040a8 val [2 3 4]
ret  ptr 0xc000004078 val [2 3 4]
```

##### 触发扩容时，切片值传递的情况

上面例子中，值传递实参、形参`slice.array`地址相同情况下， 修改副本会影响实参， 



参考：

- [《Go程序员面试笔试宝典》](https://golang.design/go-questions/)
- [面试快答](https://learnku.com/articles/69250)
- [切片在函数传递中的使用](https://juejin.cn/post/6888117219213967368)